import pandas as pd
from typing import Callable
from psycopg2.extensions import connection
from pathlib import Path
from jinja2 import Template
from threading import Thread
from queue import Queue
from pandabox.tools import Panda, PandaBox


class DbQueries:
    """
    A class used to group database queries together and provide managed threaded execution.
    The methods of this class are dynamically generated by passing a Path object
    to the constructor. This Path is then searched for files with a .sql extension, and with
    each file found, a method with the signature `fetch_<my_query_name>` is generated. The
    query can then be referenced by the name of the .sql file, omitting the .sql extension.
    """

    def __init__(self, query_path: Path, db_connection: connection, **params):
        """

        Args:
            query_path: Path object to desired directory conatining .sql files
            db_connection: The connection object to desired database.
        """
        self.params = params
        self.query_path = query_path
        self.db_connection = db_connection
        self.query_names = []

        queries = [q for q in query_path.absolute().glob('*.sql')]

        for q in queries:
            name = q.name.split('.')[0]
            templated_query = self._render_sql_template(q.read_text())
            method = self._get_data_method_factory(name=name, query=templated_query)
            setattr(self, f"fetch_{name}", method)
            setattr(self, f"{name}_query", templated_query)
            self.query_names.append(name)

    def _render_sql_template(self, query: str) -> str:
        template = Template(source=query,
                            line_comment_prefix='--',
                            autoescape=True)
        return template.render(params=self.params)

    def _get_data_method_factory(self, name: str, query: str) -> Callable:
        def get_data():
            data = pd.read_sql(query, self.db_connection, parse_dates=True)
            return Panda(name=name, data=data)

        return get_data

    @staticmethod
    def _thread_wrapper(method: Callable, queue: Queue) -> None:
        data = method()
        queue.put(data)

    def fetch_one(self, name: str) -> Panda:
        """
        Return the data from a single query by name
        Args:
            name: name of the desired query to execute
        Returns:
            Panda: A simple data class
        """
        name = f"fetch_{name}"
        method = getattr(self, name)
        return method()

    def fetch_many(self, *names) -> PandaBox:
        """
        Fetch multiple data sets using multi-threading
        Args:
            *names: list of query names to fetch

        Returns:
            PandaBox: Collection class which allows access to data frames by name
        """
        queue = Queue()
        methods = [getattr(self, f"fetch_{name}") for name in names]
        threads = []

        for method in methods:
            thread = Thread(target=self._thread_wrapper, args=(method, queue))
            thread.start()
            threads.append(thread)

        for thread in threads:
            thread.join()

        results = [queue.get() for thread in threads]
        return PandaBox(*results)

    def fetch_all(self) -> PandaBox:
        """
        Fetches all data sets as found in the query_path
        Returns:
            PandaBox: Collection of all fetched data sets accessible by name
        """
        return self.fetch_many(*self.query_names)
